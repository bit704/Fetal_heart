# -*- coding: utf-8 -*-

import MySQLdb
import gzip
import json

def txt_data_writer(filename):
    
    fileObject=open(filename+'.txt','w')
    
    conn=MySQLdb.connect(host='localhost',user='root',passwd='King5dom9yjh2018',db='test1')
    cursor=conn.cursor()
    for id in range(60000):
        L=[]
        sql="select id,data,nst_result from export_data where id=%s"%id
        cursor.execute(sql)
        for(resId,resData,resnst)in cursor:
            if(resData): #if data is not null, execute gzip
                L.append(int(resnst))
                data = gzip.decompress(resData)
                cnt=0
                for element in json.loads(data):
                    cnt=cnt+1   #count data length,if length is more than 2400,cut
                    if(cnt>2400):
                        break
                    if('y' in element.keys()):
                        L.append(int(element['y']))
                    else:
                        L.append(0)
        print(id,len(L))

        if(isvalid(L)):
            for i in range(len(L)):
                fileObject.write('%s'%L[i])
                fileObject.write(' ')
            fileObject.write('\n')
                
            
    cursor.close()
    conn.close()
    fileObject.close()
    return 0

def isvalid(L): #判断该数据是否有效，总缺失长度大于120、最大连续缺失长度大于30的数据判为无效
    zero_count=0             #一段连续缺失的长度
    total_zero_cout=0        #总的缺失长度
    max_continuous_cout=0    #最大连续缺失长度
    L.append(1)  #末尾加个1，避免以下计算漏掉末尾的连续缺失值
    
    #print(len(L))
    
    if(len(L)<2402):  #去掉长度小于2402的数据
        return False
        
    for i in range(1,2402):
        if(L[i]==0):
            zero_count+=1
        else:
            if(zero_count>max_continuous_cout):
                max_continuous_cout=zero_count #更新最大连续缺失长度
            total_zero_cout+=zero_count        #计入总缺失长度
            if(zero_count>0):
                repair(L, i-zero_count, i-1)       #修复数据
            zero_count=0  
                              
    if(total_zero_cout>120 or max_continuous_cout>30): 
        return False
    else: 
        return True
    
def repair(L,l,r): #用线性插值法修复数据
    if(l>r): return 0
    if(l==1 or r==2401):  #缺失值只有一边有参考值
        if(l==1):
            p=L[r+1]
        else:
            p=L[l-1]
        for i in range(l,r+1):
            L[i]=p
    else:                #缺失值两边都有参考值
        k=((float)(L[r+1])-(float)(L[l-1]))/(r-l+2) #计算斜率
        head=(float)(L[l-1])
        for i in range(l,r+1):
            p=(int)(head+(i-l+1)*k)
            L[i]=str(p)
            
    return 0
   
